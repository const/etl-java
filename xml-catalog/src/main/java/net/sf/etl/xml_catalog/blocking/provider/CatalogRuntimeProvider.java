/*
 * Reference ETL Parser for Java
 * Copyright (c) 2000-2022 Konstantin Plotnikov
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package net.sf.etl.xml_catalog.blocking.provider;

import net.sf.etl.xml_catalog.blocking.provider.schema.SchemaProviderModule;
import net.sf.etl.xml_catalog.event.CatalogContext;
import net.sf.etl.xml_catalog.event.CatalogFile;
import net.sf.etl.xml_catalog.event.CatalogRequest;
import net.sf.etl.xml_catalog.event.CatalogResolutionEvent;
import net.sf.etl.xml_catalog.event.CatalogResourceUsage;
import net.sf.etl.xml_catalog.util.BinaryKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.net.URL;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;
import java.util.WeakHashMap;

/**
 * The runtime resolver for the catalog.
 */
public final class CatalogRuntimeProvider implements CatalogProvider {
    /**
     * The secure random to use.
     */
    private static final SecureRandom RANDOM = new SecureRandom();
    /**
     * Length in bytes of generated random suffix (it is then converted to hex, so amount would double).
     */
    private static final int RANDOM_SUFFIX_LENGTH = 32;
    /**
     * The logger.
     */
    private static final Logger LOG = LoggerFactory.getLogger(CatalogRuntimeProvider.class);
    /**
     * The lock for synthetic catalogs.
     */
    private final Object syntheticCatalogsLock = new Object();
    /**
     * The synthetic catalogs generated by the provider.
     * // TODO should it be named flywieght catalogs?
     */
    private final WeakHashMap<CatalogRequest, CatalogProvider> syntheticCatalogs
            = new WeakHashMap<>();
    /**
     * The handlers for the catalogs by URI schema.
     * TODO more flexible mechanism that allows multiple registrations for the single schema (like JDBC DriverManager)
     */
    private final Map<String, CatalogProvider> schemaCatalogProviders = // NOPMD
            new HashMap<>();
    /**
     * The next provider.
     */
    private final CatalogProvider nextProvider;

    /**
     * The default constructor that uses {@link CatalogDirectProvider} as the next provider.
     */
    public CatalogRuntimeProvider() {
        this(new CatalogDirectProvider());
    }

    /**
     * This catalog provider.
     *
     * @param nextProvider the next provider
     */
    public CatalogRuntimeProvider(final CatalogProvider nextProvider) {
        this.nextProvider = nextProvider;
    }

    @Override
    public CatalogResolutionEvent getCatalog(final CatalogContext catalogContext, final CatalogRequest request) {
        final CatalogProvider catalogFileCreator;
        CatalogProvider schemaFileCreator;
        synchronized (syntheticCatalogsLock) {
            catalogFileCreator = syntheticCatalogs.get(request);
            try {
                schemaFileCreator = schemaCatalogProviders.get(new URI(request.getSystemId()).getScheme());
            } catch (Throwable t) {
                schemaFileCreator = null;
            }
        }
        if (catalogFileCreator != null) {
            return catalogFileCreator.getCatalog(catalogContext, request);
        }
        if (schemaFileCreator != null) {
            return schemaFileCreator.getCatalog(catalogContext, request);
        }
        return nextProvider.getCatalog(catalogContext, request);
    }

    /**
     * Register purely synthetic catalog. Such catalogs could not be reproduced from URL, since they could rely on
     * information that is available only in the runtime. For example, it could be classpath of some specific class
     * instance. And that class might be loaded in the different ClassLoaders on the same JVM. Note, that the callable
     * is asked on each catalog request, the caching is supposed to be implemented on other level.
     *
     * @param systemId           the system
     * @param randomSuffix       if true, the random suffix is appended to the catalog name
     * @param catalogFileCreator the callable that creates catalog
     * @return the catalog request. Note that if this catalog request instance is garbage collected,
     * the catalog stops to be resolved. So keep it around until you no more need it. However, you should not
     * reference this catalog request from catalogFileCreator, since that object is strongly referenceable.
     */
    public CatalogRequest registerSyntheticCatalog(final String systemId, final boolean randomSuffix,
                                                   final CatalogProvider catalogFileCreator) {
        String requestSystemId;
        if (randomSuffix) {
            requestSystemId = systemId + BinaryKey.fromRandom(RANDOM, RANDOM_SUFFIX_LENGTH);
        } else {
            requestSystemId = systemId;
        }
        return registerSyntheticCatalogProvider(new CatalogRequest(requestSystemId), catalogFileCreator);
    }

    /**
     * Register purely synthetic catalog with externally defined request. Such catalogs could not be reproduced from
     * URL, since they could rely on  information that is available only in the runtime. For example, it could be
     * classpath of some specific class instance. And that class might be loaded in the different ClassLoaders on
     * the same JVM. Note, that the callable is asked on each catalog request, the caching is supposed to be
     * implemented on other level.
     *
     * @param request            if true, the random suffix is appended to the catalog name
     * @param catalogFileCreator the callable that creates catalog
     * @return the catalog request. Note that if this catalog request instance is garbage collected,
     * the catalog stops to be resolved. So keep it around until you no more need it. However, you should not
     * reference this catalog request from catalogFileCreator, since that object is strongly referenceable.
     */
    public CatalogRequest registerSyntheticCatalogProvider(final CatalogRequest request,
                                                           final CatalogProvider catalogFileCreator) {
        synchronized (syntheticCatalogsLock) {
            syntheticCatalogs.put(request, catalogFileCreator);
        }
        return request;
    }

    /**
     * The vector provider.
     *
     * @param systemId     the system prefix
     * @param randomSuffix if true, random suffix is generated
     * @param uriList      the requests to use (when catalog is requested toArray() method is executed on it)
     * @return the vector provider
     */
    public CatalogRequest registerVectorCatalog(final String systemId, final boolean randomSuffix,
                                                final Vector<URI> uriList) { // NOPMD
        if (uriList == null) {
            throw new IllegalArgumentException("The request vector must not be null");
        }
        return registerSyntheticCatalog(systemId, randomSuffix, makeVectorCatalogProvider(uriList));
    }

    /**
     * The vector provider.
     *
     * @param request the catalog request
     * @param uriList the requests to use (when catalog is requested toArray() method is executed on it)
     * @return the vector provider
     */
    public CatalogRequest registerVectorCatalog(final CatalogRequest request,
                                                final Vector<URI> uriList) { // NOPMD
        if (uriList == null) {
            throw new IllegalArgumentException("The request vector must not be null");
        }
        return registerSyntheticCatalogProvider(request, makeVectorCatalogProvider(uriList));
    }


    /**
     * Create provider for the vector catalog.
     *
     * @param uriList the requests.
     * @return the catalog provider
     */
    private CatalogProvider makeVectorCatalogProvider(final Vector<URI> uriList) { // NOPMD
        return new CatalogProvider() {
            @Override
            public CatalogResolutionEvent getCatalog(final CatalogContext catalogContext,
                                                     final CatalogRequest request) {
                final URI[] catalogRequests;
                try {
                    synchronized (uriList) {
                        catalogRequests = uriList.toArray(new URI[uriList.size()]);
                    }
                } catch (Throwable t) {
                    return CatalogProviders.catalogLoaded(catalogContext, request, null, t, CatalogResourceUsage.NONE);
                }
                return CatalogProviders.catalogLoaded(catalogContext, request,
                        CatalogFile.fromNextCatalogs(request.getSystemId(), Arrays.asList(catalogRequests)),
                        null, CatalogResourceUsage.NONE);
            }
        };
    }

    /**
     * Register catalog that scans for classpath.
     *
     * @param classFile the class file
     * @return the catalog that scans classpath
     */
    public CatalogRequest registerClasspathCatalog(final Class<?> classFile) {
        // attempt to get meaningful url base
        String base = "/" + classFile.getName();
        final ClassLoader classLoader = classFile.getClassLoader();
        try {
            final String name = classFile.getName();
            final URL resource = classLoader.getResource(name.replace(".", "/") + ".class");
            if (resource != null) {
                base = resource.toString();
            }
        } catch (Throwable t) {
            if (LOG.isTraceEnabled()) {
                LOG.trace("Failed to get resource", t);
            }
        }
        return registerSyntheticCatalog("x-catalog-classloader-flyweight:" + base + "/", true, new CatalogProvider() {
            @Override
            public CatalogResolutionEvent getCatalog(final CatalogContext catalogContext,
                                                     final CatalogRequest request) {
                try {
                    final Enumeration<URL> resources = classLoader.getResources("META-INF/xml/catalog.xml");
                    final ArrayList<URI> uriList = new ArrayList<>();
                    while (resources.hasMoreElements()) {
                        final URL url = resources.nextElement();
                        uriList.add(url.toURI());
                    }
                    return CatalogProviders.catalogLoaded(catalogContext, request,
                            CatalogFile.fromNextCatalogs(request.getSystemId(), uriList),
                            null, CatalogResourceUsage.NONE);
                } catch (Throwable t) {
                    return CatalogProviders.catalogLoaded(catalogContext, request,
                            null, t, CatalogResourceUsage.NONE);
                }
            }
        });
    }

    /**
     * Register schema provider.
     *
     * @param schema   the schema name
     * @param provider the provider
     */
    public void registerSchema(final String schema, final CatalogProvider provider) {
        synchronized (syntheticCatalogs) {
            schemaCatalogProviders.put(schema, provider);
        }
    }

    /**
     * Forget schema provider.
     *
     * @param schema   the schema name
     * @param provider the provider
     */
    public void removeSchema(final String schema, final CatalogProvider provider) {
        synchronized (syntheticCatalogs) {
            final CatalogProvider expected = schemaCatalogProviders.get(schema);
            if (expected == provider) { // NOPMD
                schemaCatalogProviders.remove(schema);
            }
        }
    }

    /**
     * Register schema module in the catalog provider.
     *
     * @param module the module
     */
    public void registerSchemaModule(final SchemaProviderModule module) {
        for (final String schema : module.supportedUriSchemas()) {
            registerSchema(schema, module.getProvider(schema));
        }
    }

    /**
     * Remove schema module from the catalog provider.
     *
     * @param module the module
     */
    public void removeModule(final SchemaProviderModule module) {
        for (final String schema : module.supportedUriSchemas()) {
            removeSchema(schema, module.getProvider(schema));
        }
    }

    // TODO resolution filters  (catalog result caching)
    // TODO schema handlers that handle the failure and go for the next handler for the schema
}
